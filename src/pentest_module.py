import json
import pickle
import os
import textwrap
import time
import subprocess
import pexpect
import ftplib 
from cvss import CVSS3
import socket
import shutil 
# Import các hàm từ llm_api.py
from gemini_api import LLMAPI, GeminiConfig
from prompt_class import PromptStore
from attack_state import attackState
from path_module import Path
from rag import RAG_module
import re

from dotenv import load_dotenv

# Tải các biến môi trường từ tệp .env
load_dotenv()

# Lấy giá trị của API_KEY

class pentest_module:
 
    def __init__(self ,reasoning_model="gemini-1.5-pro", parsing_model="gemini-1.5-flash",instructor_dir="../docs", log_dir="../logs", api_key=os.getenv("API_KEY")):
        self.log_dir = log_dir 
        # Khởi tạo ID cho các phiên làm việc với LLM
        self.planner = LLMAPI(GeminiConfig(model=reasoning_model,api_key=api_key))
        self.executor=  LLMAPI(GeminiConfig(model=reasoning_model,api_key=api_key))
        self.summarizer =  LLMAPI(GeminiConfig(model=parsing_model,api_key=api_key))
        self.extractor= LLMAPI(GeminiConfig(model=reasoning_model,api_key=api_key))
        self.instructor = RAG_module(document_path=instructor_dir, google_api_key=api_key)

        self.prompts = PromptStore()
        self.history = {"penheal": [], "console": [], "user": []}
        self.all_paths = []
        self.counterfactual_prompt = ""
       

    def initialize(self):

        # Khởi tạo các phiên làm việc với LLM
        self.planner_id = self.planner.send_new_message(self.prompts.planner_prompt)[1]
        self.executor_id = self.executor.send_new_message(self.prompts.task_session_init)[1]
        self.summarizer_id = self.summarizer.send_new_message(self.prompts.summarizer_prompt)[1]
        self.extractor_id = self.extractor.send_new_message(self.prompts.extractor_prompt)[1]

        # Lấy thông tin mô tả từ người dùng
        init_description = input("Please describe the penetration testing task in one line, including the target IP, task type, etc.\n>")
        
        self.history["user"].append(init_description)
        
        prefixed_init_description = self.prompts.task_description + init_description
        print("Constructing Initial Attack Plan...")
        attack_plan_raw = self.planner.send_message(prefixed_init_description, self.planner_id)
        attack_plan = attack_plan_raw.split("$")[0]
        print("Initial attack tree:")
        print(attack_plan)
        self.history["penheal"].append(attack_plan)
        state = attackState(attack_plan=attack_plan, target=init_description)
        return state

    def summarize_result(self, text) -> str:
        prompt = "Here is the content to be summarized: "
        text = " ".join(text).replace("\r", " ").replace("\n", " ")
        wrapped_text = textwrap.fill(text, 8000).split("\n")
        summarized_content = ""

        for wrapped_input in wrapped_text:
            summarized_content += self.summarizer.send_message(
                f"{prompt} {wrapped_input}", self.summarizer_id)
        return summarized_content

    def update_attack_plan(self, state):
        prompt = self.prompts.update_attack_plan_prompt
        # **Crucial Change:** Include failure information explicitly
        failure_info = ""
        if "Exploit timed out" in state.prev_result or "Exploit failed" in state.prev_result:
            failure_info = f"The previous exploit attempt for '{state.prev_command}' failed. Consider alternative attack vectors."
        content = f"Previous command: {state.prev_command}\nPrevious result: {state.prev_result}\n{failure_info}"
        new_attack_plan = self.planner.send_message(prompt + content, self.planner_id)

        # Enhanced Manual Review Check (more robust)
        if ("no further actions" in new_attack_plan.lower() or 
            "manual review" in new_attack_plan.lower() or
            "no other vulnerabilities" in new_attack_plan.lower()):
            print("Manual review or no further actions suggested by LLM.")
            return "!Manual Review Required!"

        return new_attack_plan
    
    
    

    def get_exact_command(self, state):
        """Gets the next command, preventing repetition within the current attack path."""
        prompt = self.prompts.get_exact_command_prompt
        excerpt_list = self.instructor.ask_question(state.attack_plan)
        content = f"Here is the attack plan: {state.attack_plan}\nHere is a brief introduction to the task: {state.target}\n{self.prompts.msfconsole_commands}\n"
        instruction = "Here is some info from the knowledge base for your reference:"
        for excerpt in excerpt_list:
            instruction += "\n" + excerpt

        max_attempts = 2
        attempts = 0

        while attempts < max_attempts:
            commands_raw = self.executor.send_message(prompt + content + instruction, self.executor_id)
            commands = commands_raw.split("$")[:-1]
                
            if not any(cmd in state.prev_command for cmd in commands):
                state.prev_command.extend(commands)
                return "$".join(commands) + "$"  # Return as single string

            print(f"LLM generated a duplicate command. Retrying (Attempt {attempts + 1})...")
            attempts += 1
        print("Failed to get a unique command. Returning None.")
        return None            



    def clean_command(self, command):
        """Removes backticks, extra whitespace, and handles special commands."""

        cleaned_command = command.strip().replace("```", "") # Remove all backticks

        return cleaned_command  # Return the cleaned command



    def execute_command(self, command_list):
        """Executes a list of commands, handling MSFconsole, ftp, and other commands."""

        print("Lists of commands to be executed:")
        for command in command_list:
            print(command)

        result_list = []

        msf_list = [cmd for cmd in command_list if "msfconsole" in cmd]
        other_list = [cmd for cmd in command_list if "msfconsole" not in cmd]

        if msf_list:
            child = pexpect.spawn("msfconsole -q", encoding='utf-8')

            # Use a more robust prompt pattern
            marker = r'msf6 .* > '

            for command in msf_list:
                if "msfconsole: " in command:
                    actual_command = command.split("msfconsole: ")[1].strip()
                    print(f"Executing msfconsole command: {actual_command}")
                    child.sendline(actual_command)

                    # Dynamic timeout based on command type
                    if "exploit" in actual_command.lower():
                        child.timeout = 180  # Longer timeout for exploits
                    else:
                        child.timeout = 30   # Shorter timeout for other commands


                    try:
                        child.expect([marker, "Exploit failed", "[-] Failed", pexpect.TIMEOUT, pexpect.EOF])
                        output = child.before.strip() 
                        clean_output = re.sub(r'\x1b\[[0-9;]*m', '', output).strip()  # Strip ANSI escape codes and whitespace
                        print(f"Output:\n{clean_output}")
                        result_list.append(clean_output)


                        # Exploit specific handling
                        if "exploit" in actual_command.lower() and ("Exploit failed" not in clean_output and "[-] Failed" not in clean_output and child.after != pexpect.TIMEOUT):
                             # Example of how to proceed if exploit successful:
                            child.sendline('sessions -i 1')  # Check for a session
                            child.expect(marker, timeout=30) # Timeout for session check
                            session_output =  re.sub(r'\x1b\[[0-9;]*m', '', child.before.strip()).strip()
                            print(f"Session check output:\n{session_output}")
                            result_list.append(session_output)  # Add session output



                    except (pexpect.TIMEOUT, pexpect.EOF) as e:
                        print(f"Error or Timeout on command: {actual_command}\n{e}")
                        output = child.before.strip() + str(e)  # Capture output and error
                        result_list.append(f"Error/Timeout: {output}")



                self.update_history("pentestGPT", command)
                self.update_history("console", result_list[-1] if result_list else "No Output")

            child.sendline("exit -y")
            try:
                child.expect(pexpect.EOF, timeout=15)
            except pexpect.TIMEOUT:
                child.close(force=True)

        for command in other_list:
            try:
                command = self.clean_command(command)
                print(f"Executing command: {command}")

                if "ftp" in command:
                    result = self.handle_ftp_command(command)
                elif "telnet" in command:
                    result = self.handle_telnet(command)
                  # Pass to telnet/nc handler
                elif "nc" in command: 
                    result = self.handle_nc(command)  
                elif "nikto" in command:
                    # Enhanced Nikto handling
                    nikto_path = shutil.which("nikto")
                    if not nikto_path:
                        result = "Error: Nikto not installed or not in PATH"
                    else:
                        try:
                            nikto_args = command.split()[1:]
                            full_nikto_command = [nikto_path] + nikto_args
                            
                            nikto_result = subprocess.run(
                                full_nikto_command,
                                capture_output=True,
                                text=True,
                                check=True,
                                shell=False
                            )
                            result = re.sub(r'\x1b\[[0-9;]*m', '', nikto_result.stdout).strip()
                        
                        except subprocess.CalledProcessError as nikto_error:
                            result = (
                                f"Nikto Execution Error:\n"
                                f"Return Code: {nikto_error.returncode}\n"
                                f"Error: {nikto_error.stderr}"
                            )
   
                
                
                else:  # Regular shell commands
                    process = subprocess.run(command, shell=True, capture_output=True, text=True, check=True)
                    result = process.stdout

                    if process.returncode != 0:  # Check exit code
                        raise subprocess.CalledProcessError(process.returncode, process.args, output=process.stdout, stderr=process.stderr)

                print("Command executed successfully:")
                print(result)
                result_list.append(result)

            except subprocess.CalledProcessError as e:
                error_output = f"Error executing command: {command}\nReturn Code: {e.returncode}\nStderr: {e.stderr}"
                print(error_output)
                result_list.append(error_output)

            self.update_history("pentestGPT", command)
            self.update_history("console", result if 'result' in locals() else error_output)


        return result_list


    def handle_ftp_command(self, command):
        """Handles ftp commands, including anonymous login and basic file listing."""
        try:
            host, *commands = command.split() # Split to get host and subsequent commands
            host = host.replace("ftp", "").strip() # Remove "ftp" and extra whitespace
            try:
                ip_address = socket.gethostbyname(host) # Resolve hostname
                print(f"Resolved {host} to {ip_address}")
            except socket.gaierror as e:
                return f"Hostname Resolution Error: {e}"

            with ftplib.FTP() as ftp:
                ftp.connect(host, timeout=10) # Connect with timeout
                ftp.login("anonymous", "anonymous")  # Anonymous login

                output = ""
                for ftp_cmd in commands: # Execute any commands after 'ftp <host>'
                    if ftp_cmd.lower() == "ls": # Use LIST instead of ls for portability
                        ftp_cmd = "LIST"
                    response = ftp.sendcmd(ftp_cmd) # Send command to FTP server
                    output += response + "\n"
                    if ftp_cmd.upper() == "LIST": # Retrieve the listing data after LIST command
                        data = []
                        ftp.retrlines('LIST', data.append)
                        output += "\n".join(data) + "\n"  # Format data from retrlines
                    # other potential ftp commands like GET, PUT, etc.
                    # Could be added here if needed.
                return output


        except ftplib.all_errors as e: # Catch FTP errors
            return f"FTP Error: {e}"

        except (ValueError, IndexError):
            return f"Error parsing FTP command: {command}"




    def handle_telnet(self, command):
        """Handles telnet commands for Metasploitable-like systems."""
        parts = command.split()
        
        # Check if telnet is available
        if not shutil.which('telnet'):
            return "Telnet command not found. Please install telnet."

        res = ""
        child = None
        try:
            # Spawn telnet with explicit host
            host = parts[1] if len(parts) > 1 else "10.0.3.128"
            
            # Use pexpect.spawn with Metasploitable-specific expect patterns
            child = pexpect.spawn(f'telnet {host}', encoding='utf-8', timeout=15)
            
            # Expect login prompt with specific Metasploitable banner
            index = child.expect([
                r'.*metasploitable login:',  # Metasploitable login prompt
                r'.*login:',                 # Generic login prompt
                pexpect.TIMEOUT, 
                pexpect.EOF
            ], timeout=10)

            if index == 0 or index == 1:  # Successfully reached login prompt
                res = child.before + child.after
                print(f"Connected. Received banner: {res}")
                
                # Attempt login with default Metasploitable credentials
                child.sendline("msfadmin")
                login_index = child.expect([
                    r'.*Password:',  # Password prompt
                    r'.*#',          # Root shell prompt
                    pexpect.TIMEOUT
                ], timeout=5)
                
                if login_index == 0:
                    # Send password
                    child.sendline("msfadmin")
                    
                    # Expect shell prompt or additional prompts
                    shell_index = child.expect([
                        r'.*\$',     # User shell prompt
                        r'.*#',      # Root shell prompt
                        pexpect.TIMEOUT
                    ], timeout=5)
                    
                    if shell_index < 2:
                        # Successful login
                        res += child.before + child.after
                        print("Login successful.")
                    else:
                        res += "Login failed: Timeout after password."
                elif login_index == 1:
                    # Direct shell access
                    res += "Direct shell access obtained."
                else:
                    res += "Login failed: Timeout at password prompt."
            
            elif index == 2:  # Timeout
                res = "Connection timed out."
                print(res)
            elif index == 3:  # EOF
                res = "Connection closed unexpectedly."
                print(res)

            # Capture any additional output
            try:
                child.expect(pexpect.EOF, timeout=3)
                res += child.before
            except:
                pass

        except pexpect.TIMEOUT:
            res = "Connection timed out."
            print(res)
        except pexpect.EOF:
            res = "Connection closed unexpectedly."
            print(res)
        except Exception as e:
            res = f"An unexpected error occurred: {str(e)}"
            print(res)
        finally:
            # Ensure child process is closed
            if child and child.isalive():
                try:
                    child.close(force=True)
                except:
                    pass

        return res

    def handle_nc(self, command):
        """Handles netcat (nc) commands."""
        parts = command.split()
        
        # Check if nc is available
        if not shutil.which('nc'):
            return "Netcat (nc) command not found. Please install netcat."

        res = ""
        child = None
        try:
            child = pexpect.spawn(command)
            child.expect(r'.*220.*|.*#|.*\$|.*>', timeout=10)
            res += child.before.decode() + child.after.decode()

            # Add specific nc handling logic here if needed
            # For example, banner grabbing or basic connection testing

        except pexpect.TIMEOUT:
            print("Timeout waiting for service response.")
            res += "Connection timed out."
        except pexpect.EOF:
            print("Connection closed unexpectedly.")
            res += "Connection closed unexpectedly."
        except Exception as e:
            print(f"An unexpected error occurred: {e}")
            res += str(e)
        finally:
            if child and child.isalive():
                child.close()
        return res



    def update_history(self, key, value):
        """Helper function to update the history dictionary."""
        if key not in self.history:
            self.history[key] = []
        self.history[key].append(value)
        
    
    def load_history(self, log_path):  # Function to load session history
        try:
            with open(log_path, "r") as f:  # Open in read mode ('r')
                self.history = json.load(f)
                print(f"Session history loaded from {log_path}")
                return True # Return True for success
        except FileNotFoundError:
            print(f"Log file not found: {log_path}. Starting a new session.")
            return False # Return False for failure
        except json.JSONDecodeError:  # Handle invalid JSON
            print(f"Invalid JSON in log file: {log_path}.  Starting a new session.")
            return False
        except Exception as e:  # Catch any other file loading error
            print(f"Error loading log file: {e}. Starting a new session.")
            return False

 
    def input_handler(self, state):
        """Handles user input, updates the attack plan, gets and executes commands."""

        # 0. Summarize previous results if a command was executed
        if state.prev_command:
            print(f"Previous command: {state.prev_command}")
            if "nmap --script vuln" in state.prev_command:
                summarized_prev_result = self.summarize_result(state.prev_result + [self.prompts.summarized_scan_result])
            else:
                summarized_prev_result = self.summarize_result(state.prev_result)

            state.prev_result = summarized_prev_result  # Update state with summarized result
            print("Summarized previous result:")
            print(summarized_prev_result)

            # 1. Update the attack tree based on the results
            new_attack_plan = self.update_attack_plan(state)

            # Handle success or manual review conditions
            if "!Attack successful!" in new_attack_plan:
                print("Attack successful! Exiting the session...")
                print("Remember to document the successful attack.", new_attack_plan)
                return None
            
            if new_attack_plan == "!Manual Review Required!":
                print("Penetration testing concluded. Manual review required.")
                return None

            state.attack_plan = new_attack_plan
            print("Updated attack tree:")
            print(new_attack_plan)

        # Counterfactual prompt (only after loading history and if not the first iteration)
        if not state.prev_command and self.count > 0 and hasattr(self, 'history_loaded') and self.history_loaded:
            print("Refreshing counterfactual prompt based on previous session's findings...")
            altered_init_prompt = self.refresh_counterfactual_prompt(state.attack_plan)
            new_attack_plan = self.planner.send_message(altered_init_prompt, self.planner_id)
            state.attack_plan = new_attack_plan
            print("Updated attack tree after counterfactual prompt:")
            print(new_attack_plan)
            self.history_loaded = False  # Reset to avoid repeated counterfactual prompting

        # 2. Reset previous commands and get new commands for this path
        state.prev_command = []
        commands_string = self.get_exact_command(state)

        if commands_string is None:
            print("No commands could be generated. Moving to next task or exiting.")
            return None

        command_list = commands_string.split("$")[:-1]

        # 3. Execute the commands and update state
        result_list = self.execute_command(command_list)
        updated_state = attackState(attack_plan=state.attack_plan, target=state.target,
                                      prev_command=commands_string, prev_result=result_list,
                                      )
        return updated_state

    def pentest_given_state(self, init_state):
        state_list = [init_state]
        state = init_state

        # Enter the main loop
        while True:
            # Update the state using input_handler
            state = self.input_handler(state)

            if not state:  # Check if input_handler returned None (end condition)
                if state_list[-1].attack_plan == "!Manual Review Required!":
                    print("Penetration testing concluded. Manual review required.")
                break

            # Append the valid state to state_list
            state_list.append(state)

            # Update `successful_exploits` and `potential_exploits` if applicable
            if hasattr(state, "successful_exploits") and hasattr(state, "potential_exploits"):
                # Example: Update based on conditions or extractor results
                if "msfadmin" in state.prev_result.lower() or "root" in state.prev_result.lower():
                    state.successful_exploits.append(state.prev_command)


        # Ensure state_list has at least 2 states before proceeding
        if len(state_list) < 2:
            print("Error: state_list does not have enough states.")
            timestamp = time.time()
            log_name = f"pentestGPT_log_{str(timestamp)}.txt"
            log_path = os.path.join(self.log_dir, log_name)
            with open(log_path, "w") as f:
                json.dump(self.history, f)
            return state_list, None

        # Log the session if valid
        timestamp = time.time()
        log_name = f"pentestGPT_log_{str(timestamp)}.txt"
        log_path = os.path.join(self.log_dir, log_name)
        with open(log_path, "w") as f:
            json.dump(self.history, f)

        return state_list, state_list[-2].attack_plan

    
    
    def refresh_counterfactual_prompt(self, current_attack_plan):
        for path in self.all_paths:
            if len(path.vulnerability) == 0:
                path.get_vuln_name(self.extractor, self.extractor_id)
            print("Vul used:")
            print(path.vulnerability)

        # Improved counterfactual prompt construction
        counterfactual_prompt = self.counterfactual_prompt  # Start with the template
        failed_commands = []
        for path in self.all_paths:
            if "Exploit timed out" in path.results or "Exploit failed" in path.results: # Check result of whole path
                failed_commands.extend(path.commands) # Add ALL commands from failed paths

        if failed_commands:
            counterfactual_prompt += "\nThe following commands have also been tried and were unsuccessful:\n"
            for cmd in failed_commands:
                counterfactual_prompt += f"* {cmd}\n"

        vulnerability_list = ""
        for i, path in enumerate(self.all_paths):
            vulnerability_list += f"{i+1}. {path.vulnerability}\n"  # Format vulnerabilities
        # Replace the placeholder *after* building the list
        counterfactual_prompt = counterfactual_prompt.replace("[List of Vulnerabilities]", vulnerability_list)
        # Add the current attack plan for context
        counterfactual_prompt += f"\nCurrent Attack Plan:\n{current_attack_plan}\n"

        # Clearer instruction for a new plan
        counterfactual_prompt += """Now, considering these vulnerabilities are no longer exploitable,
        and taking the current attack plan into account, develop a new attack plan."""
        #new_attack_plan = self.planner.send_message(counterfactual_prompt, self.planner_id)
        return counterfactual_prompt
    
    def makeup_pentest(self,vuln_info_path):
        # load the paths from the file
        print("Starting the additional pentest session...")
        with open(vuln_info_path, "rb") as f:
            self.potential_paths = pickle.load(f)
        
        # update the attack plan with the vulnerabilities mentioned
        # first get the vulnerabilities from the paths
        path_summaries = ""
        for i, path in enumerate(self.potential_paths):
            path_summaries += str(i+1) + ". " + path.get_cve_id() + "\n"
        
        prompt = "Please create an attack plan based on the potential vulnerabilities described above\n"
        updated_attack_plan = self.planner.send_message(prompt + path_summaries, self.planner_id)
        print("Updated attack tree: ")
        print(updated_attack_plan)
        
        init_state = self.initialize()
        for self.count in range(20):
            # initialize alternate instruction
            print(f"Exploring path {self.count + 1}")
            if self.count > 0:
                init_state.attack_plan = updated_attack_plan
            state_list, updated_attack_plan = self.pentest_given_state(init_state)
            
            cur_path = Path(state_list)
            
            self.all_paths.append(cur_path)
            
            # dump the paths into a file for future reference
            log_path = self.log_dir + "/additional.pkl"
            # save it in the logs folder
            with open(log_path, "wb") as f:
                pickle.dump(self.all_paths, f)
        return self.all_paths

    def extract_IP(self):
        # tell the planner to extract the IP address
        text = "Please extract the IP address from the given text in the format $IP$"
        ip_string = self.extractor.send_message(text, self.extractor_id)
        ip = ip_string.split("$")[1]
        return ip
    

    def clean_json_response(self,response):
        """
        Clean JSON response by removing 'json', backticks, extra whitespace, 
        and any trailing characters after valid JSON
        """
        # Remove 'json' and backticks
        response_cleaned = response.replace("json", "").strip('`').strip()
        
        # Try to find the last closing brace and trim everything after it
        try:
            last_brace_index = response_cleaned.rindex('}')
            response_cleaned = response_cleaned[:last_brace_index + 1]
        except ValueError:
            pass  # If no closing brace found, keep the original string
        
        return response_cleaned


 
 
    def extract_path_attributes(self, path):
        all_states = path.state_list
        extracted_states = []
        
        for state in all_states:
            try:
                extracted_state = {
                    "attack_plan": state.attack_plan,
                    "target": state.target,
                    "prev_command": state.prev_command,
                    "prev_result": state.prev_result,
                    "successful_exploits": state.successful_exploits or [],
                }
                extracted_states.append(extracted_state)
            except AttributeError as e:
                print(f"Warning: Failed to extract state attributes - {e}")
        
        # Debugging print
        print("Extracted states:", extracted_states)
        
        # Prepare prompt
        prompt = "The states I give you are: " + json.dumps(extracted_states)
        extracted_prompt = self.prompts.extracted_prompt
        
        # Send message to extractor
        response = self.extractor.send_message(extracted_prompt + prompt, self.extractor_id)
        
        # Clean JSON response
        response_cleaned = self.clean_json_response(response)
        print("Response from extractor:", response_cleaned)
        
        try:
            cve_info = json.loads(response_cleaned)
        except json.JSONDecodeError:
            print("Failed to decode JSON response from extractor")
            return
        
        # Kiểm tra và xử lý thông tin CVE hợp lệ
        if cve_info.get("cve_id"):
            path.port = cve_info.get("port")
            path.service = cve_info.get("service")
            path.vulnerability = cve_info.get("vulnerability")
            path.severity = cve_info.get("severity")
            path.cve_id = cve_info.get("cve_id")
            path.description = cve_info.get("description")
        else:
            print("No valid CVE information found in the response")
            return path

    def main(self):
        init_state = self.initialize()        
        latest_log = None
        for filename in os.listdir(self.log_dir):
            if filename.startswith("pentestGPT_log_") and filename.endswith(".txt"):
                if latest_log is None or filename > latest_log:
                    latest_log = filename

        log_path = os.path.join(self.log_dir, latest_log) if latest_log else None

        # --- Initialize LLMs *before* any potential use ---
        if not hasattr(self, 'planner_id'):  # Initialize only if not already done
            self.initialize()


        if log_path and self.load_history(log_path):
            self.history_loaded = True

            # --- Use PromptStore for history-based prompt ---
            prompt = self.prompts.continue_pentest_prompt.format(history=json.dumps(self.history, indent=4))


            print("Constructing initial attack plan based on previous session...")
            attack_plan_raw = self.planner.send_message(prompt, self.planner_id)  # planner_id is now available!
            attack_plan = attack_plan_raw.split("$")[0]
            print("Initial attack tree (based on history):")
            print(attack_plan)
            self.history["penheal"].append(attack_plan) # Update the history

            init_state = attackState(attack_plan=attack_plan, target=self.history['user'][-1] if self.history.get('user') else "No previous target")


        else:  # No/invalid history, start new session
            self.history_loaded = False
 # Initialize only here

        # --- Pentesting Loop (common to both cases) ---
        updated_attack_plan = None
        for self.count in range(5):
            # ... (rest of the loop - unchanged)
            print(f"Exploring path {self.count + 1}")
            if self.count > 0 and self.history_loaded:
                    init_state.attack_plan = self.refresh_counterfactual_prompt(init_state.attack_plan)  # Use updated prompt
                    self.history_loaded = False # Reset so this is only done once
            state_list, updated_attack_plan = self.pentest_given_state(init_state)
            
            
            cur_path = Path(state_list)

            self.extract_path_attributes(cur_path)
            self.all_paths.append(cur_path)                    

            init_state.attack_plan = updated_attack_plan
            
            log_path = os.path.join(self.log_dir, "raw.pkl")
            with open(log_path, "wb") as f:
                pickle.dump(self.all_paths, f)

            exit_prompt = "Do you want to continue the session? (yes/no): "
            exit_response = input(exit_prompt)
            if "n" in exit_response.lower():  # Case-insensitive check for 'no'
                break
 
 
           
if __name__ == "__main__":
    pentest_module = pentest_module(reasoning_model="gemini-1.5-pro", parsing_model="gemini-1.5-flash", log_dir="../logs", api_key=os.getenv("API_KEY"))
    pentest_module.main()
    


